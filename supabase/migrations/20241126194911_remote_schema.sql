create sequence "public"."test_cron_log_id_seq";

drop policy "only admin can update rows" on "public"."employees";

drop policy "only superadmin can update rows" on "public"."employees";

drop policy "only superadmins and admins can insert rows" on "public"."employees";

drop policy "all can read rows" on "public"."folders";

drop policy "only admins can insert rows" on "public"."folders";

drop policy "only admins can update rows" on "public"."folders";

drop policy "only superadmins can delete rows" on "public"."folders";

drop policy "only superadmins can insert rows" on "public"."folders";

drop policy "only superadmins can update rows" on "public"."folders";

drop policy "admin update" on "public"."profile";

drop policy "all can see all rows" on "public"."profile";

drop policy "delete only superadmins" on "public"."profile";

drop policy "insert to profile table only admin or superadmin" on "public"."profile";

drop policy "superadmin update" on "public"."profile";

revoke delete on table "public"."folders" from "anon";

revoke insert on table "public"."folders" from "anon";

revoke references on table "public"."folders" from "anon";

revoke select on table "public"."folders" from "anon";

revoke trigger on table "public"."folders" from "anon";

revoke truncate on table "public"."folders" from "anon";

revoke update on table "public"."folders" from "anon";

revoke delete on table "public"."folders" from "authenticated";

revoke insert on table "public"."folders" from "authenticated";

revoke references on table "public"."folders" from "authenticated";

revoke select on table "public"."folders" from "authenticated";

revoke trigger on table "public"."folders" from "authenticated";

revoke truncate on table "public"."folders" from "authenticated";

revoke update on table "public"."folders" from "authenticated";

revoke delete on table "public"."folders" from "service_role";

revoke insert on table "public"."folders" from "service_role";

revoke references on table "public"."folders" from "service_role";

revoke select on table "public"."folders" from "service_role";

revoke trigger on table "public"."folders" from "service_role";

revoke truncate on table "public"."folders" from "service_role";

revoke update on table "public"."folders" from "service_role";

alter table "public"."folders" drop constraint "folders_parent_id_fkey";

alter table "public"."folders" drop constraint "folders_pkey";

drop index if exists "public"."folders_pkey";

drop table "public"."folders";

create table "public"."driver_history" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "drive_start" text,
    "drive_end" text,
    "vehicle_id" bigint,
    "driver_id" uuid default gen_random_uuid(),
    "description" text,
    "is_edited" boolean
);


alter table "public"."driver_history" enable row level security;

create table "public"."incidents" (
    "id" bigint generated by default as identity not null,
    "vehicle_id" bigint,
    "incident_date" text,
    "description" text,
    "damage_severity" text,
    "repair_cost_estimate" text,
    "repair_date" text,
    "repair_completed" boolean default false,
    "reporting_user_id" uuid,
    "photos_url" text,
    "created_at" timestamp without time zone default (now() AT TIME ZONE 'utc'::text)
);


alter table "public"."incidents" enable row level security;

create table "public"."notifications" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "title" text,
    "description" text,
    "is_read" boolean default false
);


alter table "public"."notifications" enable row level security;

create table "public"."test_cron_log" (
    "id" integer not null default nextval('test_cron_log_id_seq'::regclass),
    "log_message" text,
    "created_at" timestamp without time zone default now()
);


create table "public"."vehicles" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "profile_id" uuid,
    "license_plate" text,
    "profile_picture_url" text,
    "make" text,
    "model" text,
    "year" text,
    "color" text,
    "vin" text,
    "km_age" text,
    "last_service_date" text,
    "state" text default '''active''::text'::text,
    "next_service_date" text,
    "location" text
);


alter table "public"."vehicles" enable row level security;

alter table "public"."employees" add column "department" text;

alter table "public"."employees" add column "location" text;

alter sequence "public"."test_cron_log_id_seq" owned by "public"."test_cron_log"."id";

CREATE UNIQUE INDEX driver_history_pkey ON public.driver_history USING btree (id);

CREATE UNIQUE INDEX incidents_id_key ON public.incidents USING btree (id);

CREATE UNIQUE INDEX incidents_pkey ON public.incidents USING btree (id);

CREATE UNIQUE INDEX notifications_pkey ON public.notifications USING btree (id);

CREATE UNIQUE INDEX test_cron_log_pkey ON public.test_cron_log USING btree (id);

CREATE UNIQUE INDEX vehicles_pkey ON public.vehicles USING btree (id);

alter table "public"."driver_history" add constraint "driver_history_pkey" PRIMARY KEY using index "driver_history_pkey";

alter table "public"."incidents" add constraint "incidents_pkey" PRIMARY KEY using index "incidents_pkey";

alter table "public"."notifications" add constraint "notifications_pkey" PRIMARY KEY using index "notifications_pkey";

alter table "public"."test_cron_log" add constraint "test_cron_log_pkey" PRIMARY KEY using index "test_cron_log_pkey";

alter table "public"."vehicles" add constraint "vehicles_pkey" PRIMARY KEY using index "vehicles_pkey";

alter table "public"."driver_history" add constraint "driver_history_driver_id_fkey" FOREIGN KEY (driver_id) REFERENCES employees(profile_id) not valid;

alter table "public"."driver_history" validate constraint "driver_history_driver_id_fkey";

alter table "public"."driver_history" add constraint "driver_history_vehicle_id_fkey" FOREIGN KEY (vehicle_id) REFERENCES vehicles(id) not valid;

alter table "public"."driver_history" validate constraint "driver_history_vehicle_id_fkey";

alter table "public"."incidents" add constraint "incidents_id_key" UNIQUE using index "incidents_id_key";

alter table "public"."incidents" add constraint "incidents_reporting_user_id_fkey" FOREIGN KEY (reporting_user_id) REFERENCES employees(profile_id) not valid;

alter table "public"."incidents" validate constraint "incidents_reporting_user_id_fkey";

alter table "public"."incidents" add constraint "incidents_vehicle_id_fkey" FOREIGN KEY (vehicle_id) REFERENCES vehicles(id) ON DELETE CASCADE not valid;

alter table "public"."incidents" validate constraint "incidents_vehicle_id_fkey";

alter table "public"."vehicles" add constraint "vehicles_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES employees(profile_id) not valid;

alter table "public"."vehicles" validate constraint "vehicles_profile_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.check_expiring_documents()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  emp RECORD;
BEGIN
  -- Überprüfung auf ablaufende oder abgelaufene Dokumente
  FOR emp IN
    SELECT first_name, last_name, driver_license_end_date, id_card_end_date, profile_id
    FROM employees
    WHERE 
      (driver_license_end_date IS NOT NULL AND driver_license_end_date::DATE <= (NOW() + INTERVAL '1 month')::DATE)
      OR
      (id_card_end_date IS NOT NULL AND id_card_end_date::DATE <= (NOW() + INTERVAL '1 month')::DATE)
  LOOP
    -- Benachrichtigung einfügen
    INSERT INTO notifications (created_at, title, description, id)
    VALUES (
      NOW(),
      'Dokument läuft ab',
      'Das Dokument von ' || emp.first_name || ' ' || emp.last_name || ' läuft ab oder ist bereits abgelaufen. Bitte überprüfen Sie die Daten.',
      gen_random_uuid()
    );
  END LOOP;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.notify_on_incident_insert()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
  INSERT INTO notifications (created_at, title, description, id)
  VALUES (
    NOW(),  -- Zeitstempel
    'Neuer Vorfall',  -- Titel der Benachrichtigung
    -- Beschreibung mit `vehicle_id` und `id` aus der Tabelle `incidents`
    'Ein neuer Vorfall wurde gemeldet. Vorfall-ID: ' || NEW.id || ', Fahrzeug-ID: ' || COALESCE(NEW.vehicle_id::TEXT, 'Keine Fahrzeug-ID angegeben'),
    gen_random_uuid()  -- Generiere eine zufällige UUID für die Benachrichtigung
  );

  RETURN NEW;
END;$function$
;

CREATE OR REPLACE FUNCTION public.test_cron_function()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO test_cron_log (log_message) VALUES ('Cron-Job ausgeführt!');
END;
$function$
;

grant delete on table "public"."driver_history" to "anon";

grant insert on table "public"."driver_history" to "anon";

grant references on table "public"."driver_history" to "anon";

grant select on table "public"."driver_history" to "anon";

grant trigger on table "public"."driver_history" to "anon";

grant truncate on table "public"."driver_history" to "anon";

grant update on table "public"."driver_history" to "anon";

grant delete on table "public"."driver_history" to "authenticated";

grant insert on table "public"."driver_history" to "authenticated";

grant references on table "public"."driver_history" to "authenticated";

grant select on table "public"."driver_history" to "authenticated";

grant trigger on table "public"."driver_history" to "authenticated";

grant truncate on table "public"."driver_history" to "authenticated";

grant update on table "public"."driver_history" to "authenticated";

grant delete on table "public"."driver_history" to "service_role";

grant insert on table "public"."driver_history" to "service_role";

grant references on table "public"."driver_history" to "service_role";

grant select on table "public"."driver_history" to "service_role";

grant trigger on table "public"."driver_history" to "service_role";

grant truncate on table "public"."driver_history" to "service_role";

grant update on table "public"."driver_history" to "service_role";

grant delete on table "public"."incidents" to "anon";

grant insert on table "public"."incidents" to "anon";

grant references on table "public"."incidents" to "anon";

grant select on table "public"."incidents" to "anon";

grant trigger on table "public"."incidents" to "anon";

grant truncate on table "public"."incidents" to "anon";

grant update on table "public"."incidents" to "anon";

grant delete on table "public"."incidents" to "authenticated";

grant insert on table "public"."incidents" to "authenticated";

grant references on table "public"."incidents" to "authenticated";

grant select on table "public"."incidents" to "authenticated";

grant trigger on table "public"."incidents" to "authenticated";

grant truncate on table "public"."incidents" to "authenticated";

grant update on table "public"."incidents" to "authenticated";

grant delete on table "public"."incidents" to "service_role";

grant insert on table "public"."incidents" to "service_role";

grant references on table "public"."incidents" to "service_role";

grant select on table "public"."incidents" to "service_role";

grant trigger on table "public"."incidents" to "service_role";

grant truncate on table "public"."incidents" to "service_role";

grant update on table "public"."incidents" to "service_role";

grant delete on table "public"."notifications" to "anon";

grant insert on table "public"."notifications" to "anon";

grant references on table "public"."notifications" to "anon";

grant select on table "public"."notifications" to "anon";

grant trigger on table "public"."notifications" to "anon";

grant truncate on table "public"."notifications" to "anon";

grant update on table "public"."notifications" to "anon";

grant delete on table "public"."notifications" to "authenticated";

grant insert on table "public"."notifications" to "authenticated";

grant references on table "public"."notifications" to "authenticated";

grant select on table "public"."notifications" to "authenticated";

grant trigger on table "public"."notifications" to "authenticated";

grant truncate on table "public"."notifications" to "authenticated";

grant update on table "public"."notifications" to "authenticated";

grant delete on table "public"."notifications" to "service_role";

grant insert on table "public"."notifications" to "service_role";

grant references on table "public"."notifications" to "service_role";

grant select on table "public"."notifications" to "service_role";

grant trigger on table "public"."notifications" to "service_role";

grant truncate on table "public"."notifications" to "service_role";

grant update on table "public"."notifications" to "service_role";

grant delete on table "public"."test_cron_log" to "anon";

grant insert on table "public"."test_cron_log" to "anon";

grant references on table "public"."test_cron_log" to "anon";

grant select on table "public"."test_cron_log" to "anon";

grant trigger on table "public"."test_cron_log" to "anon";

grant truncate on table "public"."test_cron_log" to "anon";

grant update on table "public"."test_cron_log" to "anon";

grant delete on table "public"."test_cron_log" to "authenticated";

grant insert on table "public"."test_cron_log" to "authenticated";

grant references on table "public"."test_cron_log" to "authenticated";

grant select on table "public"."test_cron_log" to "authenticated";

grant trigger on table "public"."test_cron_log" to "authenticated";

grant truncate on table "public"."test_cron_log" to "authenticated";

grant update on table "public"."test_cron_log" to "authenticated";

grant delete on table "public"."test_cron_log" to "service_role";

grant insert on table "public"."test_cron_log" to "service_role";

grant references on table "public"."test_cron_log" to "service_role";

grant select on table "public"."test_cron_log" to "service_role";

grant trigger on table "public"."test_cron_log" to "service_role";

grant truncate on table "public"."test_cron_log" to "service_role";

grant update on table "public"."test_cron_log" to "service_role";

grant delete on table "public"."vehicles" to "anon";

grant insert on table "public"."vehicles" to "anon";

grant references on table "public"."vehicles" to "anon";

grant select on table "public"."vehicles" to "anon";

grant trigger on table "public"."vehicles" to "anon";

grant truncate on table "public"."vehicles" to "anon";

grant update on table "public"."vehicles" to "anon";

grant delete on table "public"."vehicles" to "authenticated";

grant insert on table "public"."vehicles" to "authenticated";

grant references on table "public"."vehicles" to "authenticated";

grant select on table "public"."vehicles" to "authenticated";

grant trigger on table "public"."vehicles" to "authenticated";

grant truncate on table "public"."vehicles" to "authenticated";

grant update on table "public"."vehicles" to "authenticated";

grant delete on table "public"."vehicles" to "service_role";

grant insert on table "public"."vehicles" to "service_role";

grant references on table "public"."vehicles" to "service_role";

grant select on table "public"."vehicles" to "service_role";

grant trigger on table "public"."vehicles" to "service_role";

grant truncate on table "public"."vehicles" to "service_role";

grant update on table "public"."vehicles" to "service_role";

create policy "admin can see all rows"
on "public"."driver_history"
as permissive
for select
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "admins can insert rows"
on "public"."driver_history"
as permissive
for insert
to authenticated
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "admins can update rows"
on "public"."driver_history"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "only superadmins can delete rows"
on "public"."driver_history"
as permissive
for delete
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmin can see all rows"
on "public"."driver_history"
as permissive
for select
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can insert rows"
on "public"."driver_history"
as permissive
for insert
to authenticated
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can update rows"
on "public"."driver_history"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "admin can update rows"
on "public"."employees"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "superadmin can update rows"
on "public"."employees"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins and admins can insert rows"
on "public"."employees"
as permissive
for insert
to authenticated
with check (((( SELECT profile.role
   FROM profile
  WHERE (auth.uid() = employees.profile_id)) = 'superadmin'::text) OR (( SELECT profile.role
   FROM profile
  WHERE (auth.uid() = employees.profile_id)) = 'admin'::text)));


create policy "admins can insert rows"
on "public"."incidents"
as permissive
for insert
to authenticated
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "admins can select all rows"
on "public"."incidents"
as permissive
for select
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "admins can update rows"
on "public"."incidents"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "only superadmins can delete rows"
on "public"."incidents"
as permissive
for delete
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can insert rows"
on "public"."incidents"
as permissive
for insert
to authenticated
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can select all rows"
on "public"."incidents"
as permissive
for select
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can update rows"
on "public"."incidents"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "admin can delete rows"
on "public"."notifications"
as permissive
for select
to public
using ((( SELECT profile_1.role
   FROM profile profile_1
  WHERE (auth.uid() = profile_1.id)) = 'superadmin'::text));


create policy "admins can insert rows"
on "public"."notifications"
as permissive
for insert
to public
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "admins can see all rows"
on "public"."notifications"
as permissive
for select
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "admins can update rows"
on "public"."notifications"
as permissive
for update
to public
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "superadmin can select all rows"
on "public"."notifications"
as permissive
for select
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can delete rows"
on "public"."notifications"
as permissive
for delete
to authenticated
using ((( SELECT profile_1.role
   FROM profile profile_1
  WHERE (auth.uid() = profile_1.id)) = 'superadmin'::text));


create policy "superadmins can insert rows"
on "public"."notifications"
as permissive
for insert
to authenticated
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can update rows"
on "public"."notifications"
as permissive
for update
to public
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "admin can update rows"
on "public"."profile"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile_1.role
   FROM profile profile_1
  WHERE (profile_1.id = auth.uid())) = 'admin'::text));


create policy "admin or superadmin can insert rows"
on "public"."profile"
as permissive
for insert
to authenticated
with check (((( SELECT profile_1.role
   FROM profile profile_1
  WHERE (auth.uid() = profile_1.id)) = 'superadmin'::text) OR (( SELECT profile_1.role
   FROM profile profile_1
  WHERE (auth.uid() = profile_1.id)) = 'admin'::text)));


create policy "everyone can see all rows"
on "public"."profile"
as permissive
for select
to authenticated
using (true);


create policy "superadmin can update rows"
on "public"."profile"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile_1.role
   FROM profile profile_1
  WHERE (profile_1.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can delete rows"
on "public"."profile"
as permissive
for delete
to authenticated
using ((( SELECT profile_1.role
   FROM profile profile_1
  WHERE (auth.uid() = profile_1.id)) = 'superadmin'::text));


create policy "admins can insert rows"
on "public"."vehicles"
as permissive
for insert
to authenticated
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "admins can see all rows"
on "public"."vehicles"
as permissive
for select
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "admins can update rows"
on "public"."vehicles"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'admin'::text));


create policy "only superadmins can delete rows"
on "public"."vehicles"
as permissive
for delete
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "only superadmins can update rows"
on "public"."vehicles"
as permissive
for update
to authenticated
using (true)
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can insert rows"
on "public"."vehicles"
as permissive
for insert
to authenticated
with check ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "superadmins can see all rows"
on "public"."vehicles"
as permissive
for select
to authenticated
using ((( SELECT profile.role
   FROM profile
  WHERE (profile.id = auth.uid())) = 'superadmin'::text));


create policy "users can see their own vehicles"
on "public"."vehicles"
as permissive
for select
to authenticated
using ((( SELECT profile.id
   FROM profile
  WHERE (profile.id = auth.uid())) = profile_id));


CREATE TRIGGER insert_notification_on_incident AFTER INSERT ON public.incidents FOR EACH ROW EXECUTE FUNCTION notify_on_incident_insert();


